<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Moody Animation</title>
    <link type="text/css" rel="stylesheet" href="/static/css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.2.0/socket.io.min.js"></script>
    <style>
			body { margin: 0; }
		</style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/"
        }
      }
      </script>
      <script>
        var socket = io.connect('http://127.0.0.1:5000/');
        socket.on('new_data', function(msg) {
          document.getElementById('response').innerHTML = msg.data[1];
          document.getElementById('message_bubble').innerHTML = msg.data[0];
        }
      )
      </script>
      
      
</head>
<body style="background-color: black; width: 100%;">
	<div style="position:relative; display: inline-block; width: 100%;">
    <p id="response" style="position: absolute; top: 1em;">{{bot_answer}}</p>
    
    <div style="position: absolute; top: 5em;">
      <!-- <script type="module" src="/static/js/single_cube.js"></script> -->
      <!-- <script type="module">

        import * as THREE from 'three';
  
        import Stats from 'three/addons/libs/stats.module.js';
  
        import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
  
        let camera, controls, scene, renderer, stats;
  
        let mesh, geometry, material, clock;
  
        const worldWidth = 128, worldDepth = 128;

        // let mouseX = 0, mouseY = 0;

        // let windowHalfX = window.innerWidth / 2;
        // let windowHalfY = window.innerHeight / 2;

        // document.addEventListener( 'mousemove', onDocumentMouseMove );
  
        init();
  
        function init() {
  
          camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );
          camera.position.y = 200;
  
          clock = new THREE.Clock();
  
          scene = new THREE.Scene();
          scene.background = new THREE.Color( 0xaaccff );
          scene.fog = new THREE.FogExp2( 0xaaccff, 0.0007 );
  
          geometry = new THREE.PlaneGeometry( 20000, 20000, worldWidth - 1, worldDepth - 1 );
          geometry.rotateX( - Math.PI / 2 );
  
          const position = geometry.attributes.position;
          position.usage = THREE.DynamicDrawUsage;
  
          for ( let i = 0; i < position.count; i ++ ) {
  
            const y = 35 * Math.sin( i / 2 );
            position.setY( i, y );
  
          }
  
          const texture = new THREE.TextureLoader().load( '/static/bubble' );
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set( 5, 5 );
          texture.colorSpace = THREE.SRGBColorSpace;
  
          material = new THREE.MeshBasicMaterial( { color: 0x0044ff, map: texture } );
  
          mesh = new THREE.Mesh( geometry, material );
          scene.add( mesh );
  
          renderer = new THREE.WebGLRenderer( { antialias: true } );
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight * 0.98);
          renderer.setAnimationLoop( animate );
          document.body.appendChild( renderer.domElement );
  
          controls = new FirstPersonControls( camera, renderer.domElement );
  
          controls.movementSpeed = 500;
          controls.lookSpeed = 0.1;
  
          // stats = new Stats();
          // document.body.appendChild( stats.dom );
  
          //
  
          window.addEventListener( 'resize', onWindowResize );
  
        }
  
        function onWindowResize() {
  
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
  
          renderer.setSize( window.innerWidth, window.innerHeight );
  
          // controls.handleResize();
  
        }

        // function onDocumentMouseMove( event ) {

        // 	mouseX = ( event.clientX - windowHalfX ) / 10;
        // 	// mouseY = ( event.clientY - windowHalfY ) * 2;

        // }
  
        //
  
        function animate() {
  
          render();
          // stats.update();
  
        }
  
        function render() {
  
          const delta = clock.getDelta();
          const time = clock.getElapsedTime() * 10;
  
          const position = geometry.attributes.position;
  
          for ( let i = 0; i < position.count; i ++ ) {
  
            const y = 35 * Math.sin( i / 5 + ( time + i ) / 7 );
            position.setY( i, y );
  
          }
  
          position.needsUpdate = true;

          // camera.position.x += ( mouseX - camera.position.x ) * .05;
          // camera.position.y += ( - mouseY - camera.position.y ) * .05;
          // camera.lookAt( scene.position );
  
          controls.update( delta );
          renderer.render( scene, camera );
  
        }
  
      </script> -->

      <script type="module">

        import * as THREE from 'three';

        import { ParallaxBarrierEffect } from 'three/addons/effects/ParallaxBarrierEffect.js';

        let container, camera, scene, renderer, effect;

        const spheres = [];

        let mouseX = 0;
        let mouseY = 0;

        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        document.addEventListener( 'mousemove', onDocumentMouseMove );

        init();

        function init() {

          container = document.createElement( 'div' );
          document.body.appendChild( container );

          camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );
          camera.position.z = 3;

          const path = '/static/HeartInTheSand/';
          const format = '.jpg';
          const urls = [
            path + 'posx' + format, path + 'negx' + format,
            path + 'posy' + format, path + 'negy' + format,
            path + 'posz' + format, path + 'negz' + format
          ];

          const textureCube = new THREE.CubeTextureLoader().load( urls );

          scene = new THREE.Scene();
          scene.background = textureCube;

          const textureSphere = new THREE.CubeTextureLoader().load(urls);

          textureSphere.mapping = THREE.CubeRefractionMapping;

          const geometry = new THREE.SphereGeometry( 0.1, 32, 16 );
          const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureSphere, refractionRatio: 0.95 } );

          for ( let i = 0; i < 500; i ++ ) {

            const mesh = new THREE.Mesh( geometry, material );

            mesh.position.x = Math.random() * 10 - 5;
            mesh.position.y = Math.random() * 10 - 5;
            mesh.position.z = Math.random() * 10 - 5;

            mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;

            scene.add( mesh );

            spheres.push( mesh );

          }

          //

          renderer = new THREE.WebGLRenderer();
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setAnimationLoop( animate );
          container.appendChild( renderer.domElement );

          const width = window.innerWidth;
          const height = window.innerHeight * 0.98;

          effect = new ParallaxBarrierEffect( renderer );
          effect.setSize( width, height );

          //

          window.addEventListener( 'resize', onWindowResize );

        }

        function onWindowResize() {

          windowHalfX = window.innerWidth / 2;
          windowHalfY = window.innerHeight / 2;

          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          effect.setSize( window.innerWidth, window.innerHeight );

        }

        function onDocumentMouseMove( event ) {

          mouseX = ( event.clientX - windowHalfX ) / 100;
          mouseY = ( event.clientY - windowHalfY ) / 100;

        }

        //

        function animate() {

          const timer = 0.0001 * Date.now();

          camera.position.x += ( mouseX - camera.position.x ) * .05;
          camera.position.y += ( - mouseY - camera.position.y ) * .05;

          camera.lookAt( scene.position );

          for ( let i = 0, il = spheres.length; i < il; i ++ ) {

            const sphere = spheres[ i ];

            sphere.position.x = 5 * Math.cos( timer + i );
            sphere.position.y = 5 * Math.sin( timer + i * 1.1 );

          }

          effect.render( scene, camera );

        }

      </script>

    </div>
    <div id="message_bubble" class="bubble left" style="position: absolute; left: 4em; top: 52em;">{{question}}</div>
  </div>
    
</body>
</html>